# Air Quality Monitoring System

This is a complete air quality monitoring system with a secure HTTPS backend and a frontend dashboard.

## Features

- HTTPS-enabled backend for secure data transmission
- RESTful API for air quality data
- API key authentication for secure data submission
- Data validation to ensure data integrity
- Rate limiting to prevent abuse
- Comprehensive logging for monitoring and debugging
- SQLite database for data storage
- CORS support for frontend integration
- Environment variable configuration
- Robust error handling
- Interactive frontend dashboard with real-time data visualization

## Setup

### Prerequisites

- Rust and Cargo installed
- OpenSSL installed (for certificate generation)

### Backend Setup

1. Navigate to the backend directory:
   ```
   cd webserver/backend
   ```

2. Generate self-signed certificates for HTTPS:
   ```
   cargo run --bin generate_certs
   ```

3. Create a `.env` file in the backend directory with the following content:
   ```
   DATABASE_URL=../database/air_quality.db
   HOST=0.0.0.0
   PORT=3001
   API_KEY=your_secure_api_key_here
   RUST_LOG=info
   USE_HTTPS=true  # Default is HTTPS mode
   RATE_LIMIT_PER_MINUTE=60  # Adjust as needed
   ```

4. Run the backend server (HTTPS is enabled by default):
   ```
   cargo run
   ```

   To run with HTTP instead (not recommended):
   ```
   USE_HTTPS=false cargo run
   ```

   To adjust rate limiting:
   ```
   RATE_LIMIT_PER_MINUTE=120 cargo run
   ```

   When using HTTPS, you'll need to accept the self-signed certificate warnings in your browser.

### Frontend Setup

1. Navigate to the frontend directory:
   ```
   cd webserver/frontend
   ```

2. Run the frontend development server:
   ```
   trunk serve --open
   ```

## Accessing the Application

### HTTP Mode (Default)
- Frontend: http://localhost:8080
- Backend API: http://127.0.0.1:3001/airquality

### HTTPS Mode
- Backend API: https://127.0.0.1:3001/airquality

When using HTTPS, you'll need to accept the self-signed certificate warnings in your browser. This is normal for development environments. In production, you would use proper SSL certificates.

## API Endpoints

### GET /airquality

Retrieves all air quality records from the database.

### POST /airquality

Creates a new air quality record. Requires API key authentication.

Example request body:
```json
{
  "timestamp": "2025-03-30 12:34:56",
  "temperature": 18.5,
  "humidity": 60.2,
  "pm1_0": 5.1,
  "pm2_5": 10.2,
  "pm10": 20.5,
  "co2": 400.0
}
```

## Setting Up Cloudflare Tunnel

To expose your backend to the internet securely using Cloudflare Tunnel:

1. Create a Cloudflare account if you don't have one
2. Install the Cloudflare Tunnel client (cloudflared)
3. Authenticate with Cloudflare:
   ```
   cloudflared tunnel login
   ```
4. Create a tunnel:
   ```
   cloudflared tunnel create air-quality-backend
   ```
5. Configure your tunnel by creating a config file `config.yml`:
   ```yaml
   tunnel: <TUNNEL_ID>
   credentials-file: /path/to/.cloudflared/<TUNNEL_ID>.json

   ingress:
     - hostname: air-quality.yourdomain.com
       service: https://localhost:3001
       originRequest:
         noTLSVerify: true  # Only for self-signed certificates
     - service: http_status:404
   ```

6. Route DNS to your tunnel:
   ```
   cloudflared tunnel route dns <TUNNEL_ID> air-quality.yourdomain.com
   ```
7. Start the tunnel:
   ```
   cloudflared tunnel run air-quality-backend
   ```

8. Make sure your backend is running with HTTPS enabled:
   ```
   USE_HTTPS=true cargo run --bin backend
   ```

### Important Notes for Cloudflare Tunnel

- The backend must be running with HTTPS enabled (`USE_HTTPS=true`)
- You must use the self-signed certificates generated by the `generate_certs` tool
- The Cloudflare Tunnel will handle the public-facing HTTPS with proper certificates
- Your local backend will use self-signed certificates for the connection between Cloudflare and your server

## Security Considerations

- Always use HTTPS when exposing your API to the internet
- Keep your API key secret and rotate it periodically
- Enable rate limiting to prevent abuse
- Monitor your server logs for suspicious activity
- Use proper SSL certificates in production (not self-signed)
- Consider using a reverse proxy like Nginx for additional security
- Regularly update dependencies to patch security vulnerabilities
- Back up your database regularly
